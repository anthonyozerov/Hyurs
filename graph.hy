(require
 [hy.contrib.walk [let]]
 [utils [*]])
(import
  math
  random
  [utils [*]]
  stats)

(setv tau (* 2 math.pi))

(defn treelist->tag-val-lists
  [tl &optional [start-height 0] [end-height 999]]
  """ This is the main data processing function for graphs. It starts with a
      standard treelist, as generated by functions in stats.hy, and converts
      it into a full-sumtree, as done by the full-sumtree function in stats.hy.

      Next, the tree is converted into a list of (key, value) pairs,
      and with the help of some clever sorting these are conveniently
      partitioned into different lists depending on their length.

      The result is a list of lists containing (key, val) pairs for each level
      in the tree, where each level has the same sum (easy to align in graphs).
  """
  (let [sumtree
        (stats.full-sumtree tl
                            start-height
                            end-height)]
    (-> sumtree
        (stats.blown-up-treelist)
        (sort
         (fn [tree]
           (stats.tree-ranks sumtree
                             (stats.node-key tree))))
        (slice-by-len
         ; make it look at the length of the key, not key-val pair:
         first)
        rst))) ; take the rest because the first element is length zero lists

(defn tag-val-lists
  [mapping-name t1-str t2-str]
  (treelist->tag-val-lists (stats.times->treelist)))

(defn replace-uncategorised [l]
  """Replaced the Lisp symbol Uncategorised with False in the list l.
     This is done because False (equivalent to the Python value) interfaces
     better with Python code."""
  (mapl (fn [key]
          (if (= key 'Uncategorised)
            False
            key))
        l))

(defn nested-pie-ring
  [farc-fn labels vals cols cx cy start-r end-r start-angle]
  """ A helper function for the main pie chart generator below."""
  (setv dist/val (/ tau (sum vals)))
  (setv angle start-angle)
  (for [i (list (range (len vals)))]
    (let [col (get cols i)
          next-angle (+ angle
                        (* dist/val
                           (get vals i)))]
      (farc-fn cx
               cy
               start-r
               end-r
               angle
               next-angle
               col
               (if col (get labels i) ""))
      (setv angle next-angle))))

(defn nested-pie-chart
  [farc-fn col-fn vals-by-len cx cy start-radius radius-step]
  """ARGUMENTS:
  - farc-fn is a filled arc function, taking:
      cx cy radius-1 radius-2 angle-1-in-radians angle-2-in-radians color-or-false label-text
    and is responsible for collecting the output. If color-or-false is false, farc-fn
    should output the background colour.
  - col-fn is a function that takes in h-tags and returns an RGB color
  - vals-by-len is a list of tuples of h-tag, value pairs, where the ith
    element of the list is all such pairs where the h-tag has (i+1) levels,
    and the special value False has been inserted as fillers when on the next
    level something is uncategorised (e.g. a:b has value 3, but a:b:c has value
    2 and no other x such that a:b:x exists; then add False with value 1 to the
    second list in vals-by-len)
  - cx/cy are the coordinates of the centre of the graph
  - start-radius is the length from the centre to leave blank before the innermost ring
  - radius-step is the width of each ring
     RETURNS:
  - a bounding box for the chart, of the form [x1, y1, x2, y2]
  (output is assumed to be collected by farc-fn)
  """
  (defn pie-ring-iter
    [vals-by-len i]
    (if (!= i 0)
      (do
        (let [tags-vals (last vals-by-len)
              htags (mapl first tags-vals)]
          (nested-pie-ring farc-fn
                           (replace-uncategorised
                            (mapl (get-ith (- i 1))
                                  htags)) ; label is only current level of the htag
                           (mapl second
                                 tags-vals) ; this gives the values
                           (mapl col-fn
                                 htags)
                           cx
                           cy
                           (+ start-radius (* radius-step (- i 1)))
                           (+ start-radius (* radius-step i))
                           0))
        (pie-ring-iter (butlastl vals-by-len) (dec i)))))
  (pie-ring-iter vals-by-len
                 (len vals-by-len))
  ; ^ the reason we go backwards in the above is so that the chart can be drawn
  ;   even if only circle slices are supported (not "pizza rim"-shaped ones);
  ;   going 0 up would mean later slices would then go on top of earlier ones.
  (let [rings (len vals-by-len)
        total-radius (+ start-radius (* radius-step rings))]
    [(- cx total-radius) (- cy total-radius)
     (+ cx total-radius) (+ cy total-radius)]))

(defn flame-chart
  [rect-fn col-fn vals-by-len cx cy dist/val layer-width]
  """ARGUMENTS:
  - rect-fn is a filled rectangle function, taking:
      x1 y1 x2 y2 color label-text
    and is responsible for collecting the output.
  - col-fn is a function that takes in h-tags and returns an RGB color
  - vals-by-len is a list of dictionaries from h-tag to value, where the ith
    element of the list is all h-tags of (i+1) elements
  - cx/cy are the coordinates of the corner of the graph
  - dist/val is the scale: distance units per value unit
  - layer-width is the width of one layer in the flame chart
  """
  (defn layer-iter
    [vals-by-len x level]
    (if (not (empty? vals-by-len))
      (let [tags-vals (first vals-by-len)
            htags (mapl first
                        tags-vals)
            vals (mapl last
                       tags-vals)
            cols (mapl col-fn
                       htags)
            labels (replace-uncategorised
                    (mapl (get-ith level)
                          htags))]
        (setv y cy)
        (for [i (list (range (len htags)))]
          (setv yincr (* dist/val
                         (get vals i)))
          (rect-fn x
                   y
                   (+ x
                      layer-width)
                   (+ y yincr)
                   (get cols i)
                   (get labels i))
          (setv y
                (+ y yincr)))
        (layer-iter (rst vals-by-len)
                    (+ x layer-width)
                    (inc level)))))
  (layer-iter vals-by-len
              cx
              0)
  [cx
   cy
   (+ cx
      (* layer-width
         (len vals-by-len)))
   (+ cy
      (reduce + ; this is the sum of values in the first level of the graph
              (mapl last
                    (first vals-by-len))))])

(defn labelled-filled-arc-fn-gen
  [filled-arc-fn angled-text-fn background-col]
  (fn [cx cy r1 r2 ang1 ang2 col label]
    (if label
      (let [fill-col (if col col background-col)]
        (filled-arc-fn cx cy r1 r2 ang1 ang2 fill-col)
        (let [r (/ (+ r1 r2) 2)
              ang (/ (+ ang1 ang2) 2)]
          (angled-text-fn (+ cx (* r (math.cos ang)))
                          (- cy (* r (math.sin ang)))
                          (if (< (abs (- ang2 ang1))
                                 (/ tau 16)) ; ARBITRARY CONSTANT - UH OH
                            (if (and (< ang (* tau 3/4))
                                     (> ang (/ tau 4)))
                              (+ ang (/ tau 2))
                              ang)
                            (if (< ang (/ tau 2))
                              (- ang (/ tau 4))
                              (+ ang (/ tau 4))))
                          label)))
      False)))

(defn labelled-filled-rect-fn-gen
  [filled-rect-fn angled-text-fn background-col]
  (fn [x1 y1 x2 y2 col label]
    (if label
      (let [fill-col (if col col background-col)]
        (filled-rect-fn x1 y1 x2 y2 fill-col)
        (let [w (- x2 x1)
              h (- y2 y1)
              xm (/ (+ x1 x2) 2)
              ym (/ (+ y1 y2) 2)]
            (angled-text-fn xm
                            ym
                            (if (< w h)
                              (/ tau 4)
                              0)
                            label)))
      False)))

(defn labelled-line-fn-gen
  [line-fn angled-text-fn]
  (fn [x y dx dy label]
    (line-fn x y (+ x dx) (+ y dy))
    (angled-text-fn (- x (* 10 (sign dx)))
                    (- y (* 10 (sign dy)))
                    0
                    label)))

(defn draw-scale
  [labelled-line-fn sx sy dist/val maxval vertical?
   &optional [tick-length 10]]
  (defn scale-iter
    [x y val incr]
    (if (< val maxval)
      (do
        (labelled-line-fn x y
                          (if vertical? 10 0)
                          (if vertical? 0 10)
                          val)
        (if vertical?
          (scale-iter x
                      (+ y (* dist/val incr))
                      (+ val incr)
                      incr)
          (scale-iter (+ x (* dist/val incr))
                      y
                      (+ val incr)
                      incr)))))
  (scale-iter sx sy 0
              (round (/ maxval 10)))
  (labelled-line-fn sx sy
                    (if vertical?
                      0
                      (* dist/val maxval))
                    (if vertical?
                      (* dist/val maxval)
                      0)
                    ""))

(defn rand-col-fn [htag]
  (col->hex (map (fn [x] (random.randint 0 255))
                 ['three 'element 'list])))

(defn col-from-real
  [r]
  """Maps 0-1 (or any other space between integers) to a bright colour.
     The colour varies continuously with r.
  """
  (mapl (fn [x] (round (* 255
                          x x)))
        (mapl (fn [phase]
                (math.cos (+ phase (* r tau 1/2))))
              [0 (* tau 1/3) (* tau 2/3)])))

(defn gen-col-fn
  [seed]
  (defn num-iter
    [remaining-htag]
    (let [hsh (hash (first remaining-htag))]
      (if (empty? remaining-htag)
        0
        (+ (/ (* (% hsh seed)
                 (if (< 0 hsh) -1 1))
              seed)
           (/ (num-iter (rst remaining-htag))
              2))))) ; <- the bigger this number, the more htag colour is based on hierarchy
  (fn [htag]
    (col->hex (col-from-real (num-iter htag)))))

(defn make-pie-chart
  [tl start-level end-level farc-fn col-fn cx cy graph-size]
  (let [tag-val-lists (treelist->tag-val-lists tl start-level end-level)]
    (nested-pie-chart farc-fn
                      col-fn
                      tag-val-lists
                      cx
                      cy
                      0
                      (/ graph-size
                         2
                         (max 1 (len tag-val-lists))))))

(defn make-flame-chart
  [tl start-level end-level rect-fn col-fn cx cy scale layer-width]
  (let [tag-val-lists (treelist->tag-val-lists tl start-level end-level)]
    (flame-chart rect-fn
                 col-fn
                 tag-val-lists
                 cx
                 cy
                 scale
                 layer-width)))
